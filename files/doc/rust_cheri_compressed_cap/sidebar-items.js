initSidebarItems({"enum":[["Cc128","Defines the CC128 capability profile as an implementation of the CompressedCapability trait."],["Cc64","Defines the CC64 capability profile as an implementation of the CompressedCapability trait."]],"mod":[["c_funcs","Import C functions for CC64,128."],["cc128","Implements [CompressedCapability] for the CC128 capability profile."],["cc64","Implements [CompressedCapability] for the CC64 capability profile."],["wrappers","Defines easy-to-use wrapper traits for [CompressedCapability] implementations"]],"struct":[["CcxBoundsBits","Structure matching the C type `_cc_N(bounds_bits)`. Represents a floating-point encoded capability bounds."],["CcxCap","Structure matching the C type `_cc_N(cap)`. Field order and layout is binary-compatible with the C version, assuming the C preprocessor macro `_CC_REVERSE_PESBT_CURSOR_ORDER` is not defined."]],"trait":[["CompressedCapability","Trait defining an Rust version of the public API for a specific capability type. A type X implementing CompressedCapability is equivalent to the API provided by `cheri_compressed_cap_X.h` in C, where `ccx_cap_t` is equivalent to [CcxCap]."],["FfiNumType","Value which can be converted to T (a NumType). Must also be Default/Copy/Clone/Debug, so CcxCap can derive these."],["NumType","Trait that the field types defined in CompressedCapability (Length, Offset, Addr) have to implement. This asserts that a) theyâ€™re numeric, b) they support Default/Copy/Clone/Debug so that CcxCap can derive these."]],"type":[["Cc128Cap",""],["Cc64Cap",""]]});