var searchIndex = JSON.parse('{\
"rsim":{"doc":"Library for emulating various RISC-V processors. Supports …","t":[16,16,16,16,16,4,6,8,8,16,16,16,16,18,18,18,18,18,18,16,16,18,18,18,18,18,18,18,18,18,18,18,18,16,11,11,11,11,10,11,10,11,10,11,10,11,10,11,11,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,10,11,11,10,11,10,11,10,11,10,11,10,11,0,0,10,11,10,11,10,11,10,11,10,11,10,11,10,11,11,11,11,11,10,11,10,11,10,11,10,11,10,11,10,11,3,12,12,0,0,0,0,0,13,13,13,13,13,13,3,4,13,13,13,13,13,13,13,13,13,13,13,4,13,13,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,12,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,0,0,0,16,16,16,16,16,4,6,3,8,3,8,8,16,16,16,3,3,16,18,18,18,18,18,18,16,16,18,18,18,18,18,18,18,18,18,18,18,18,16,13,4,3,13,12,12,12,12,12,5,0,5,5,5,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,12,10,10,10,10,10,0,0,12,10,10,10,10,10,10,10,12,10,10,10,10,10,10,12,12,16,16,16,16,16,4,6,8,8,16,16,16,16,18,18,18,18,18,18,16,16,18,18,18,18,18,18,18,18,18,18,18,18,16,13,4,13,11,11,5,5,5,5,11,11,10,10,10,10,11,11,10,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10,10,10,10,11,10,10,10,10,10,10,10,11,11,11,11,11,11,10,11,10,10,10,10,10,12,12,3,8,3,3,11,11,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,3,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,3,8,3,8,6,10,11,11,11,11,11,11,11,11,11,5,12,11,11,11,11,11,11,11,12,11,12,11,11,11,11,11,11,11,11,12,10,11,11,11,12,12,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,10,11,11,11,11,11,11,11,13,8,4,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,12,11,11,11,11,11,11,11,11,11,11,11,10,11,13,13,13,13,4,4,4,13,13,13,4,13,13,6,4,13,13,13,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,8,3,3,8,16,8,3,6,3,3,6,3,3,3,6,6,6,6,11,11,0,10,10,10,0,12,10,11,10,11,12,12,12,12,12,0,0,12,12,11,11,11,0,12,12,10,3,3,3,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,8,3,6,6,6,6,3,12,11,11,11,11,10,10,10,12,11,11,11,11,10,11,11,11,12,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,13,13,13,3,4,4,13,13,13,3,4,13,13,4,6,6,6,6,3,4,13,13,13,4,4,17,3,6,8,8,3,8,13,13,13,12,12,11,11,10,10,0,11,11,11,0,10,11,13,13,13,13,13,13,13,13,13,13,13,13,12,12,11,11,11,5,11,11,11,10,11,11,11,10,11,10,10,10,10,11,0,5,10,11,10,10,10,11,10,10,10,10,10,11,11,11,0,6,5,12,12,12,12,12,12,12,13,13,13,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,6,8,8,10,10,10,10,10,10,10,13,13,13,4,13,13,13,13,13,13,4,4,13,13,13,13,13,4,4,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,3,3,8,5,11,11,11,11,11,11,10,11,11,5,11,11,11,11,10,11,11,10,11,11,10,11,11,10,11,11,5,10,11,11,10,11,11,10,11,11,10,11,11,10,11,11,10,11,11,11,11,11,11,11,11,12,12,4,4,4,17,3,3,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,5,11,12,12,12,13,13,13,12,12,11,13,4,13,8,3,3,3,3,3,3,12,12,12,12,10,10,10,12,12,12,12,12,12,12,12,10,10,12,12,12,12,0,12,12,12,0,0,12,12,12,12,12,12,12,12,12,12,12,3,3,3,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,12,11,12,12,11,11,11,11,11,11,11,11,11,12,11,3,3,3,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,12,11,12,12,11,11,11,11,11,11,11,11,11,12,11,13,4,13,3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,12,12,11,12,11,11,11,12,12,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11],"n":["Addr","Cap","CapAddrBits","CapAddrInt","CapLen","Cc128","Cc128Cap","CheriRVFuncs","CompressedCapability","FfiLength","FfiOffset","Flags","Length","MAX_REPRESENTABLE_OTYPE","MAX_UNRESERVED_OTYPE","OTYPE_RESERVED2","OTYPE_RESERVED3","OTYPE_SENTRY","OTYPE_UNSEALED","OType","Offset","PERM_ACCESS_SYS_REGS","PERM_CINVOKE","PERM_EXECUTE","PERM_GLOBAL","PERM_LOAD","PERM_LOAD_CAP","PERM_SEAL","PERM_SETCID","PERM_STORE","PERM_STORE_CAP","PERM_STORE_LOCAL","PERM_UNSEAL","Perms","borrow","borrow_mut","clone","clone_into","compress_mem","compress_mem","compress_raw","compress_raw","decompress_mem","decompress_mem","decompress_raw","decompress_raw","extract_bounds_bits","extract_bounds_bits","fmt","from","getCapBaseBits","getCapBaseBits","getCapBounds","getCapBounds","getCapCursor","getCapCursor","getCapFlags","getCapFlags","getCapLength","getCapLength","getCapOffsetBits","getCapOffsetBits","getCapPerms","getCapPerms","getCapTop","getCapTop","getRepresentableAlignmentMask","getRepresentableAlignmentMask","getRepresentableLength","getRepresentableLength","get_alignment_mask","get_alignment_mask","get_flags","get_flags","get_otype","get_otype","get_perms","get_perms","get_representable_length","get_representable_length","get_required_alignment","get_required_alignment","get_reserved","get_reserved","get_uperms","get_uperms","hasReservedOType","hasReservedOType","inCapBounds","inCapBounds","incCapOffset","incCapOffset","into","invalidateCap","invalidateCap","isCapSealed","isCapSealed","is_representable_cap_exact","is_representable_cap_exact","is_representable_new_addr","is_representable_new_addr","make_max_perms_cap","make_max_perms_cap","memory","processor","sealCap","sealCap","setCapAddr","setCapAddr","setCapBounds","setCapBounds","setCapFlags","setCapFlags","setCapOffset","setCapOffset","setCapPerms","setCapPerms","set_bounds","set_bounds","to_owned","try_from","try_into","type_id","unsealCap","unsealCap","update_flags","update_flags","update_otype","update_otype","update_perms","update_perms","update_reserved","update_reserved","update_uperms","update_uperms","CheriAggregateMemory","base_mem","tag_mem","decode","elements","exceptions","isa_mods","models","AddUpperImmPC","BType","Branch","Custom2CHERI","FLdStType","IType","Imm","InstructionBits","JType","JumpAndLink","JumpAndLinkRegister","Load","LoadFP","LoadUpperImm","MiscMem","Op","Op32","OpImm","OpImm32","Opcode","ROrIType","RType","SType","Store","StoreFP","System","UType","VType","Vector","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","data","decode","eq","fmt","fmt","fmt","from","from","from","from_b","from_f_ld_st","from_i","from_j","from_r","from_r_or_i","from_s","from_u","from_v","get_opcode","into","into","into","new","no_extend_u32","no_extend_u64","sign_extend_i32","sign_extend_i64","sign_extend_u32","sign_extend_u64","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","width","funct3","funct3","funct3","funct3","funct3","funct3","funct6","funct7","funct7","funct7","imm","imm","imm","imm","imm","imm","mew","mop","nf","rd","rd","rd","rd","rd","rd","rd","rs1","rs1","rs1","rs1","rs1","rs1","rs1","rs2","rs2","rs2","rs2","rs2","rs2","vm","vm","width","zimm10","zimm11","cheri","memory","registers","Addr","Cap","CapAddrBits","CapAddrInt","CapLen","Cc128","Cc128Cap","CheriAggregateMemory","CheriMemory","CheriRV64RegisterFile","CheriRVFuncs","CompressedCapability","FfiLength","FfiOffset","Flags","IntegerModeCheriAggregateMemory","IntegerModeCheriRV64RegisterFile","Length","MAX_REPRESENTABLE_OTYPE","MAX_UNRESERVED_OTYPE","OTYPE_RESERVED2","OTYPE_RESERVED3","OTYPE_SENTRY","OTYPE_UNSEALED","OType","Offset","PERM_ACCESS_SYS_REGS","PERM_CINVOKE","PERM_EXECUTE","PERM_GLOBAL","PERM_LOAD","PERM_LOAD_CAP","PERM_SEAL","PERM_SETCID","PERM_STORE","PERM_STORE_CAP","PERM_STORE_LOCAL","PERM_UNSEAL","Perms","RawData","SafeTaggedCap","TagMemory","ValidCap","base_cap","base_cap","base_mem","base_mem","base_reg","cap_bounds_range","capability","check_bounds_against_capability","check_capability","check_obj_bounds_against_capability","compress_mem","compress_raw","decompress_mem","decompress_raw","extract_bounds_bits","getCapBaseBits","getCapBounds","getCapCursor","getCapFlags","getCapLength","getCapOffsetBits","getCapPerms","getCapTop","getRepresentableAlignmentMask","getRepresentableLength","get_alignment_mask","get_flags","get_otype","get_perms","get_representable_length","get_required_alignment","get_reserved","get_uperms","hasReservedOType","inCapBounds","incCapOffset","internal_mem","invalidateCap","isCapSealed","is_representable_cap_exact","is_representable_new_addr","make_max_perms_cap","memory","registers","regs","sealCap","setCapAddr","setCapBounds","setCapFlags","setCapOffset","setCapPerms","set_bounds","tag_mem","unsealCap","update_flags","update_otype","update_perms","update_reserved","update_uperms","bot","top","Addr","Cap","CapAddrBits","CapAddrInt","CapLen","Cc128","Cc128Cap","CheriRVFuncs","CompressedCapability","FfiLength","FfiOffset","Flags","Length","MAX_REPRESENTABLE_OTYPE","MAX_UNRESERVED_OTYPE","OTYPE_RESERVED2","OTYPE_RESERVED3","OTYPE_SENTRY","OTYPE_UNSEALED","OType","Offset","PERM_ACCESS_SYS_REGS","PERM_CINVOKE","PERM_EXECUTE","PERM_GLOBAL","PERM_LOAD","PERM_LOAD_CAP","PERM_SEAL","PERM_SETCID","PERM_STORE","PERM_STORE_CAP","PERM_STORE_LOCAL","PERM_UNSEAL","Perms","RawData","SafeTaggedCap","ValidCap","borrow","borrow_mut","cap_bounds_range","check_bounds_against_capability","check_capability","check_obj_bounds_against_capability","clone","clone_into","compress_mem","compress_raw","decompress_mem","decompress_raw","default","eq","extract_bounds_bits","fmt","from","from_cap","from_integer","from_tagged_mem","getCapBaseBits","getCapBounds","getCapCursor","getCapFlags","getCapLength","getCapOffsetBits","getCapPerms","getCapTop","getRepresentableAlignmentMask","getRepresentableLength","get_alignment_mask","get_flags","get_otype","get_perms","get_representable_length","get_required_alignment","get_reserved","get_uperms","hasReservedOType","inCapBounds","incCapOffset","into","invalidateCap","isCapSealed","is_representable_cap_exact","is_representable_new_addr","make_max_perms_cap","ne","sealCap","setCapAddr","setCapBounds","setCapFlags","setCapOffset","setCapPerms","set_bounds","to_cap","to_integer","to_owned","try_from","try_into","type_id","unsealCap","unwrap_cap","update_flags","update_otype","update_perms","update_reserved","update_uperms","bot","top","CheriAggregateMemory","CheriMemory","IntegerModeCheriAggregateMemory","TagMemory","as_any","as_any","base_cap","base_mem","base_mem","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","fetch_inst_u32","from","from","from","from_base","get_full_range_cap","get_io_values","internal_mem","into","into","into","load_from_memory","load_from_memory","load_maybe_cap","load_maybe_cap","new","range","range","range","read","read","read","read","store_cap","store_cap","store_maybe_cap","store_maybe_cap","store_to_memory","store_to_memory","tag_mem","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","wrap","write","write","write","write","CheriRV64RegisterFile","IntegerModeCheriRV64RegisterFile","base_cap","base_reg","borrow","borrow","borrow_mut","borrow_mut","check_addr_range_against_provenance","check_addr_range_against_provenance","check_elem_bounds_against_provenance","check_elem_bounds_against_provenance","default","dump","from","from","get_addr_provenance","get_addr_provenance","into","into","read","read","read","read_ddc_offset_cap","read_maybe_cap","read_u64","regs","reset","sreg_read_xlen","sreg_read_xlen","sreg_write_xlen","sreg_write_xlen","try_from","try_from","try_into","try_into","type_id","type_id","wrap","write","write","write","write_maybe_cap","write_u64","AggregateMemory","IOMemory","Memory","MemoryBacking","MemoryOf","MemoryResult","as_any","as_any","as_any","as_any","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","check_alignment_range","data","from","from","from","from","from_file","from_mappings","from_vec","full_range","get_io_values","halt_on_write","into","into","into","load_from_memory","load_u16","load_u32","load_u64","load_u8","mappings","range","range","range","range","range","range","read","read","read","read","read","read","read","return_address","store_to_memory","store_u16","store_u32","store_u64","store_u8","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","value","write","write","write","write","write","write","write","zeros","InvalidIndex","RegisterFile","RegisterFileError","RvRegisterFile","borrow","borrow","borrow_mut","borrow_mut","check_addr_range_against_provenance","check_elem_bounds_against_provenance","clone","clone_into","default","dump","eq","fmt","fmt","from","from","get_addr_provenance","into","into","ne","read","read","regs","reset","sreg_read_xlen","sreg_write_xlen","to_owned","to_string","try_from","try_from","try_into","try_into","type_id","type_id","write","write","AddressMisaligned","AddressUnmapped","BoundsViolation","Cap","CapOrRegister","CapabilityException","IllegalInstructionException","InexactBounds","JumpMisaligned","LengthViolation","MemoryException","MiscDecodeException","PermissionViolation","ProcessorResult","ProgramHaltedException","Reg","ResultReturned","SealViolation","TagViolation","UnimplementedInstruction","UnknownOpcode","UnsupportedParam","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","eq","eq","eq","eq","eq","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","into","into","into","into","into","ne","ne","ne","ne","ne","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","base","cap","cap","cap","cap","cap","cap","perms","size","top","addr","addr","addr","expected","expected","addr","CSRProvider","CheriVectorRegisterFile","IntVectorRegisterFile","IsaMod","Pc","PossibleXlen","Rv32im","Rv32imConn","Rv64im","Rv64imCapabilityMode","Rv64imConn","RvimConn","XCheri64","XCheri64Conn","Zicsr32","Zicsr32Conn","Zicsr64","Zicsr64Conn","borrow","borrow_mut","cheri","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","csrs","ddc","execute","from","has_csr","into","memory","memory","mode","pc","pcc","rv32im","rv64im","sreg","sreg","try_from","try_into","type_id","vector","vreg","vreg","will_handle","Rv64imCapabilityMode","XCheri64","XCheri64Conn","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","ddc","execute","execute","from","from","from","handle_cjalr","into","into","into","memory","mode","pcc","sreg","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","will_handle","will_handle","CSRProvider","Zicsr","Zicsr32","Zicsr32Conn","Zicsr64","Zicsr64Conn","ZicsrConn","_phantom","borrow","borrow","borrow_mut","borrow_mut","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","csr_providers","default","execute","from","from","has_csr","into","into","provider_of_csr","sreg","try_from","try_from","try_into","try_into","type_id","type_id","will_handle","Rv32im","borrow","borrow_mut","execute","from","into","try_from","try_into","type_id","will_handle","Rv64im","borrow","borrow_mut","execute","from","into","try_from","try_into","type_id","will_handle","ByteMask","ByteMaskLoad","ByteMaskStore","CheriVectorRegisterFile","ConfigKind","DecodedMemOp","FaultOnlyFirst","FaultOnlyFirst","Indexed","IntVectorRegisterFile","Lmul","Load","Load","MemOpDir","Provenance","Rv32v","Rv64Cheriv","Rv64v","Rvv","Sew","Store","Store","Strided","UnitStrideLoadOp","UnitStrideStoreOp","VLEN","VType","VecInterface","VecMemInterface","VecRegInterface","VectorElem","VectorRegisterFile","WholeRegister","WholeRegister","WholeRegister","_phantom_xlen","base_reg","borrow","borrow_mut","check_addr_range_against_provenance","check_elem_bounds_against_provenance","conns","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","decode","dump","dump","e1","e128","e16","e2","e32","e4","e64","e8","e8","eEighth","eHalf","eQuarter","eew","elem_within_group","exec_config","exec_load_store","execute","extract_bits","fast_check_load_store","from","get_active_segment_range","get_addr_provenance","get_load_store_accesses","has_csr","into","load_from_memory","load_to_vreg","load_vreg","load_vreg_elem","load_vreg_elem_int","load_vreg_int","new","registers","replace_bits","reset","reset","seg_masked_out","sreg_read_xlen","sreg_write_xlen","store_to_mem","store_to_memory","store_vreg","store_vreg_elem","store_vreg_elem_int","store_vreg_int","try_from","try_into","type_id","types","uVLEN","val_times_lmul_over_sew","vill","vl","vlmul","vma","vreg","vreg","vreg","vsetivli","vsetvl","vsetvli","vsew","vstart","vta","vtype","will_handle","dir","dir","dir","dir","eew","eew","eew","eew","emul","emul","emul","evl","evl","evl","evl","index_emul","index_ew","nf","nf","nf","num_regs","ordered","stride","Provenance","VecMemInterface","VecRegInterface","check_addr_range_against_provenance","check_elem_bounds_against_provenance","get_addr_provenance","load_from_memory","sreg_read_xlen","sreg_write_xlen","store_to_memory","ByteMask","ByteMaskLoad","ByteMaskStore","DecodedMemOp","FaultOnlyFirst","FaultOnlyFirst","Indexed","Indexed","Load","Load","MemOpDir","RvvMopType","Store","Store","Strided","Strided","UnitStride","UnitStrideLoadOp","UnitStrideStoreOp","WholeRegister","WholeRegister","WholeRegister","_get_encoded_emul_eew_nf","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","decode_load_store","dir","eq","eq","eq","eq","eq","evl","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","into","into","into","into","into","ne","ne","to_owned","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","dir","dir","dir","dir","eew","eew","eew","eew","emul","emul","emul","evl","evl","evl","evl","index_emul","index_ew","nf","nf","nf","num_regs","ordered","stride","ordered","CheriVectorRegisterFile","IntVectorRegisterFile","VectorRegisterFile","bit_range_for_element","borrow","borrow","borrow_mut","borrow_mut","default","default","dump","dump","dump","extract_bits","from","from","into","into","load_vreg","load_vreg","load_vreg","load_vreg_elem","load_vreg_elem","load_vreg_elem","load_vreg_elem_int","load_vreg_elem_int","load_vreg_elem_int","load_vreg_int","load_vreg_int","load_vreg_int","replace_bits","reset","reset","reset","seg_masked_out","seg_masked_out","seg_masked_out","store_vreg","store_vreg","store_vreg","store_vreg_elem","store_vreg_elem","store_vreg_elem","store_vreg_elem_int","store_vreg_elem_int","store_vreg_elem_int","store_vreg_int","store_vreg_int","store_vreg_int","try_from","try_from","try_into","try_into","type_id","type_id","vreg","vreg","ConfigKind","Lmul","Sew","VLEN","VType","VectorElem","base_reg","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","check_with_lmul","check_with_num_regs","clone","clone","clone","clone_into","clone_into","clone_into","decode","e1","e128","e16","e2","e32","e4","e64","e8","e8","eEighth","eHalf","eQuarter","eew","elem_within_group","elems_per_group","encode","eq","eq","eq","fmt","fmt","fmt","fmt","from","from","from","from","from","illegal","into","into","into","into","into","ne","num_registers_consumed","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","uVLEN","val_times_lmul_over_sew","val_times_lmul_over_sew","vill","vlmul","vma","vsetivli","vsetvl","vsetvli","vsew","vta","width_in_bytes","Capability","CheriExecMode","Integer","Processor","Processor32","ProcessorModules32","Rv64imvProcessor","Rv64imvProcessorModules","Rv64imvXCheriProcessor","Rv64imvXCheriProcessorModules","csrs","csrs","csrs","ddc","dump","exec_step","get_io_values","initial_mode","max_cap","memory","memory","memory","pc","pc","pcc","reset","running","running","running","running","rv32im","rv32imv","rv64im","rv64im","rv64im_cap","rv64imv","rv64imvxcheri","rvv","rvv","rvv","sreg","sreg","sreg","start_pc","xcheri","zicsr","zicsr","zicsr","Processor32","ProcessorCSRs32","ProcessorModules32","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","csrs","dump","exec_step","from","from","from","get_io_values","has_csr","into","into","into","memory","new","pc","process_inst","reset","running","running","rv32im","rv32im_conn","rvv","sreg","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","zicsr","zicsr_conn","Rv64imvProcessor","Rv64imvProcessorCSRs","Rv64imvProcessorModules","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","csrs","dump","exec_step","from","from","from","get_io_values","has_csr","into","into","into","memory","new","pc","process_inst","reset","running","running","rv64im","rv64im_conn","rvv","sreg","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","zicsr","zicsr_conn","Capability","CheriExecMode","Integer","Rv64imvXCheriProcessor","Rv64imvXCheriProcessorCSRs","Rv64imvXCheriProcessorModules","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","csr_atomic_read_clear","csr_atomic_read_set","csr_atomic_read_write","csrs","ddc","dump","eq","exec_step","fmt","from","from","from","from","get_io_values","has_csr","initial_mode","into","into","into","into","max_cap","memory","new","pcc","process_inst","reset","running","running","rv64im","rv64im_cap","rvv","sreg","start_pc","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","xcheri","xcheri64_conn","zicsr","zicsr_conn"],"q":["rsim","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::memory","","","rsim::processor","","","","","rsim::processor::decode","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::decode::InstructionBits","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements","","","rsim::processor::elements::cheri","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements::cheri::SafeTaggedCap","","rsim::processor::elements::cheri::capability","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements::cheri::capability::SafeTaggedCap","","rsim::processor::elements::cheri::memory","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements::cheri::registers","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements::memory","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::elements::registers","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::exceptions","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::exceptions::CapabilityException","","","","","","","","","","rsim::processor::exceptions::MemoryException","","","","","rsim::processor::exceptions::ProgramHaltedException","rsim::processor::isa_mods","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::cheri","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::csrs","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::rv32im","","","","","","","","","","rsim::processor::isa_mods::rv64im","","","","","","","","","","rsim::processor::isa_mods::vector","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::vector::DecodedMemOp","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::vector::conns","","","","","","","","","","rsim::processor::isa_mods::vector::decode","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::vector::decode::DecodedMemOp","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::vector::decode::RvvMopType","rsim::processor::isa_mods::vector::registers","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::isa_mods::vector::types","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::models","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::models::rv32imv","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::models::rv64imv","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rsim::processor::models::rv64imvxcheri","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["ccx_addr_t equivalent","","","","","Publically exposed CHERI-related structures. All pulled …","Publically exposed CHERI-related structures. All pulled …","Publically exposed CHERI-related structures. All pulled …","Publically exposed CHERI-related structures. All pulled …","ccx_length_t C-land equivalent - should have a memory …","ccx_offset_t C-land equivalent - should have a memory …","","ccx_length_t Rust-land equivalent - should be a superset …","","","","","","CCX_OTYPE_UNSEALED equivalent","","ccx_offset_t Rust-land equivalent - should be a superset …","","","","CCX_PERM_GLOBAL equivalent These are the same for 64 and …","","","","","","","","","","","","","","Generate the <code>pesbt</code> bits for a capability (the top bits, …","","Generate the <code>pesbt</code> bits for a capability (the top bits, …","","Decompress a (pesbt, cursor) pair into a capability. This …","","Decompress a (pesbt, cursor) pair into a capability. This …","","Extracts the floating-point encoded bounds from […","","","","","","","","","","","","","","","","","","","","","","","","Get a mask which aligns a bounds of some <code>length</code> to be …","","Gets the flags from the [CcxCap::cr_pesbt] field","","Gets the object type from the [CcxCap::cr_pesbt] field","","Gets the hardware-defined permissions from the […","","Get the minimum representable length greater than or …","","Get the alignment required for bounds of some <code>length</code> to …","","Gets the reserved bits from the [CcxCap::cr_pesbt] field","","Gets the user/software-defined permissions from the […","","","","","","","","","","","","","Check if the range ([CcxCap::cr_base], [CcxCap::_cr_top]) …","","Check if a capability with the parameters …","","Generate a capability for <code>base, top, cursor</code> with the …","","Publically exposed memory-related structures. Includes …","Main module with all processor elements, ISA modules, and …","","","","","","","","","","","","","Sets the capability bounds to bounds that encompass …","","","","","","","","Updates the flags field in [CcxCap::cr_pesbt]","","Updates the object type field in [CcxCap::cr_pesbt]","","Updates the hardware-defined permissions field in […","","Updates the reserved field in [CcxCap::cr_pesbt]","","Updates the user/software-defined permissions field in […","","Wrapper for AggregateMemory64 that keeps tags, supports …","","","","","","All RISC-V ISA extensions implemented as objects …","","","","","","","","","TODO - Right now this does sign extension up to 32-bits. …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Generates an immediate from data + width","Return the immediate data as a u32","Return the immediate data as a u64","Sign-extend the immediate value and return as a i32","Sign-extend the immediate value and return as a i64","Sign-extend the immediate value and return as a u32","Sign-extend the immediate value and return as a u64","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","ccx_addr_t equivalent","","","","","Defines the CC128 capability profile as an implementation …","","Wrapper for AggregateMemory64 that keeps tags, supports …","","Register file for 64-bit RISC-V that can hold tagged …","Trait exposing the utility functions used to specify …","Trait defining an Rust version of the public API for a …","ccx_length_t C-land equivalent - should have a memory …","ccx_offset_t C-land equivalent - should have a memory …","","Wrapper for a reference to CheriAggregateMemory that …","","ccx_length_t Rust-land equivalent - should be a superset …","","","","","","CCX_OTYPE_UNSEALED equivalent","","ccx_offset_t Rust-land equivalent - should be a superset …","","","","CCX_PERM_GLOBAL equivalent These are the same for 64 and …","","","","","","","","","","","Enumeration that stores either raw data or a valid …","Memory holding tags for capabilities. Implements MemoryOf…","","","","","","","Return the range of addresses you can access with a …","","Checks that a capability allows access to a given range …","Checks that a capability allows access to a <code>TData</code>-sized …","Checks that a capability allows access to a <code>TData</code>-sized …","Generate the <code>pesbt</code> bits for a capability (the top bits, …","Generate the <code>pesbt</code> bits for a capability (the top bits, …","Decompress a (pesbt, cursor) pair into a capability. This …","Decompress a (pesbt, cursor) pair into a capability. This …","Extracts the floating-point encoded bounds from […","","","","","","","","","","","Get a mask which aligns a bounds of some <code>length</code> to be …","Gets the flags from the [CcxCap::cr_pesbt] field","Gets the object type from the [CcxCap::cr_pesbt] field","Gets the hardware-defined permissions from the […","Get the minimum representable length greater than or …","Get the alignment required for bounds of some <code>length</code> to …","Gets the reserved bits from the [CcxCap::cr_pesbt] field","Gets the user/software-defined permissions from the […","","","","","","","Check if the range ([CcxCap::cr_base], [CcxCap::_cr_top]) …","Check if a capability with the parameters …","Generate a capability for <code>base, top, cursor</code> with the …","","","","","","","","","","Sets the capability bounds to bounds that encompass …","","","Updates the flags field in [CcxCap::cr_pesbt]","Updates the object type field in [CcxCap::cr_pesbt]","Updates the hardware-defined permissions field in […","Updates the reserved field in [CcxCap::cr_pesbt]","Updates the user/software-defined permissions field in […","","","ccx_addr_t equivalent","","","","","Defines the CC128 capability profile as an implementation …","","Trait exposing the utility functions used to specify …","Trait defining an Rust version of the public API for a …","ccx_length_t C-land equivalent - should have a memory …","ccx_offset_t C-land equivalent - should have a memory …","","ccx_length_t Rust-land equivalent - should be a superset …","","","","","","CCX_OTYPE_UNSEALED equivalent","","ccx_offset_t Rust-land equivalent - should be a superset …","","","","CCX_PERM_GLOBAL equivalent These are the same for 64 and …","","","","","","","","","","","Enumeration that stores either raw data or a valid …","","","","Return the range of addresses you can access with a …","Checks that a capability allows access to a given range …","Checks that a capability allows access to a <code>TData</code>-sized …","Checks that a capability allows access to a <code>TData</code>-sized …","","","Generate the <code>pesbt</code> bits for a capability (the top bits, …","Generate the <code>pesbt</code> bits for a capability (the top bits, …","Decompress a (pesbt, cursor) pair into a capability. This …","Decompress a (pesbt, cursor) pair into a capability. This …","","","Extracts the floating-point encoded bounds from […","","","Converts a capability into a SafeTaggedCap. If the …","","","","","","","","","","","","","Get a mask which aligns a bounds of some <code>length</code> to be …","Gets the flags from the [CcxCap::cr_pesbt] field","Gets the object type from the [CcxCap::cr_pesbt] field","Gets the hardware-defined permissions from the […","Get the minimum representable length greater than or …","Get the alignment required for bounds of some <code>length</code> to …","Gets the reserved bits from the [CcxCap::cr_pesbt] field","Gets the user/software-defined permissions from the […","","","","","","","Check if the range ([CcxCap::cr_base], [CcxCap::_cr_top]) …","Check if a capability with the parameters …","Generate a capability for <code>base, top, cursor</code> with the …","","","","","","","","Sets the capability bounds to bounds that encompass …","Converts a SafeTaggedCap to a Cc128Cap. If ValidCap, just …","","","","","","","Converts a SafeTaggedCap to a Cc128Cap with tag bit = …","Updates the flags field in [CcxCap::cr_pesbt]","Updates the object type field in [CcxCap::cr_pesbt]","Updates the hardware-defined permissions field in […","Updates the reserved field in [CcxCap::cr_pesbt]","Updates the user/software-defined permissions field in […","","","Wrapper for AggregateMemory64 that keeps tags, supports …","","Wrapper for a reference to CheriAggregateMemory that …","Memory holding tags for capabilities. Implements MemoryOf…","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Register file for 64-bit RISC-V that can hold tagged …","","","","","","","","","","","","","","","","","","","","","","","","Reads a valid capability from the register file.","","","","","","","","","","","","","","","","","","","","Struct that combines a set of array-backed memory …","I/O Memory Defines an address range of a single u32. …","Public trait which supplies {load,store}_u{8,16,32,64} …","Array-backed memory","Internal trait defining functions for reading/writing …","","","","","","","","","","","","Checks for address alignment and whether the address is …","","","","","","Read bytes from a file and map them to an address range. …","Take a set of mappings, verify they do not overlap, and …","Map a set of bytes to an address range. Any empty space …","","Returns a vector of all stored I/O values","","","","","","","","","","","The mapped address range for this Memory. All addresses …","","","","","","","","","","","","","Build an I/O memory with the specified address","","","","","","","","","","","","","","","","","","","","","","","Generate a vector of zeros and map it to an address range.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Enum for capability-related exceptions. Modelled after …","","","","","Error which can be raised when accessing memory","","","","Error triggered by the program in order to halt","","","","","","","Indended use: …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Register file which holds 128-bit integer vectors OR one …","Register file which holds 128-bit integer vectors.","Trait for all ISA modules.","","Trait for possible XLEN values. Used to make elements …","Base ISA module for RV32 ISAs. Implements Integer and …","","Base ISA module for RV64 ISAs. Implements Integer and …","Override for base RV64I instructions when in “…","","Connection to a RISC-V I+M ISA module.","ISA module implementing the new CHERI instructions for …","Connection to register state for 64-bit CHERI-aware ISA …","CSR unit for RV32 ISAs","","CSR unit for RV64 ISAs","","","","","Atomically read and clear specific bits in a CSR","Atomically read and set specific bits in a CSR","Atomic Read/Write a CSR","","","Execute the given instruction, returning the new PC (or …","","Does the Provider provide access to a given CSR?","","","","","","","","","","","","","","","","","Return true if this ISA module should handle the given …","Override for base RV64I instructions when in “…","ISA module implementing the new CHERI instructions for …","Connection to register state for 64-bit CHERI-aware ISA …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","CSR unit for RV32 ISAs","","CSR unit for RV64 ISAs","","References to all CSR providers","","","","","","Atomically read and clear specific bits in a CSR","Atomically read and set specific bits in a CSR","Atomic Read/Write a CSR","","","","","","Does the Provider provide access to a given CSR?","","","Explanation of return type: OK, so this is really …","","","","","","","","","Base ISA module for RV32 ISAs. Implements Integer and …","","","","","","","","","","Base ISA module for RV64 ISAs. Implements Integer and …","","","","","","","","","","Moves the contents of a mask register to/from a …","","","Register file which holds 128-bit integer vectors OR one …","Config instruction kind enum","The different kinds of RISC-V V vector loads/stores. One …","","Loads elements from contiguous segments in memory into […","Moves elements of [Self::Indexed::nf] vector register …","Register file which holds 128-bit integer vectors.","Length-Mul enum","","Load = taking values from memory and putting them in …","The “direction” of a memory operation. Used by […","Struct indicating the providence of a pointer.","RISC-V Vector unit for RV32 ISAs","RISC-V Vector unit for RV64 + CHERI ISAs","RISC-V Vector unit for RV64 non-CHERI ISAs","The Vector Unit for the processor. Stores all vector …","Selected-Element-Width enum","","Store = taking values from vector registers and putting …","Moves elements of [Self::Strided::nf] vector register …","Special variants of vector loads with unit-stride","Special variants of vector stores with unit-stride","Vector register length in bits","Vector type information","Helper type combining [VecRegInterface] and […","Common trait for interfaces to memory","","A struct describing an element of a vector register group","Trait for a vector register file where VLEN=128, ELEN=128.…","","","Moves the contents of [Self::WholeRegister::nf] vector …","","The first register of the group. Should be a multiple of …","","","Check if the provenance <code>p</code> allows accesses to the …","As for check_addr_range_against_provenance, but for a …","","","","","","","Dump vector unit state to standard output.","","On CHERI, used to load/store capabilities.","","","","","","","","","","","The element width,","The index of the element within the group","(Internal) Execute a configuration instruction, e.g. …","Execute a decoded memory access, assuming all access …","Execute a vector-specific instruction, e.g. vector …","Complementary function to [replace_bits]","Try doing fast-path capability checks for accesses for a …","","Find the last segment index that isn’t masked out. Used …","Get a raw address value + the provenance of that address …","Converts a decoded memory operation to the list of …","","","Use an address, provenance pair to read a vector element …","Load a value of width <code>eew</code> from a given address <code>addr</code>  into …","","Load a value from an element in a vertex register group, …","","","Returns an initialized vector unit.","","Function that replaces the bits of a value in a specific …","","Reset the vector unit’s state","Returns true if the mask is enabled and element <code>i</code> has …","Read a value XLEN from a register, not an address","Write a value XLEN to a register, not an address","Stores a value of width <code>eew</code> from a specific element …","Use an address, provenance pair to write a vector element …","","Store a value in an element in a vertex register group, …","","","","","","","Unsigned type of length [VLEN]","Function that evaluates (X * LMUL) / SEW from their enum …","Illegal value.","","Length multiplier. See [Lmul]","Vector mask agnostic.","","","","","","","Selected element width. See [Sew]","This is used by the hardware to support resuming vector …","Vector tail agnostic.","","","The direction, i.e. load or store","The direction, i.e. load or store","The direction, i.e. load or store","The direction, i.e. load or store","The effective element width - this is encoded in the …","The width of the elements being accessed from memory","The width of the elements being accessed. This doesn’t …","The width of the elements being accessed from memory","The effective LMUL of the operation, e.g. the size of the …","The effective LMUL of the elements being accessed from …","The effective LMUL of the operation. See […","The effective vector length - always equal to the current …","The effective vector length - always equal to the current …","The number of bytes to load, i.e. <code>ceil(vl/8)</code>","The effective vector length - always equal to the current …","The effective LMUL for the indices.","The width of the indices. Indices are byte offsets.","Number of Fields for segmented access","Number of Fields for segmented access","Number of Fields for segmented access","The number of registers to load or store. Encoded the …","Whether elements must be accessed in the order specified …","The stride, specified in bytes TODO make this signed …","Struct indicating the providence of a pointer.","Common trait for interfaces to memory","","Check if the provenance <code>p</code> allows accesses to the …","As for check_addr_range_against_provenance, but for a …","Get a raw address value + the provenance of that address …","Use an address, provenance pair to read a vector element …","Read a value XLEN from a register, not an address","Write a value XLEN to a register, not an address","Use an address, provenance pair to write a vector element …","Moves the contents of a mask register to/from a …","","","The different kinds of RISC-V V vector loads/stores. One …","","Loads elements from contiguous segments in memory into […","","Moves elements of [Self::Indexed::nf] vector register …","","Load = taking values from memory and putting them in …","The “direction” of a memory operation. Used by […","Memory OPeration enum","","Store = taking values from vector registers and putting …","","Moves elements of [Self::Strided::nf] vector register …","","Special variants of vector loads with unit-stride","Special variants of vector stores with unit-stride","","","Moves the contents of [Self::WholeRegister::nf] vector …","","","","","","","","","","","","","","","","","","","","","","Decode a Load/Store opcode into an DecodedMemOp structure.…","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The direction, i.e. load or store","The direction, i.e. load or store","The direction, i.e. load or store","The direction, i.e. load or store","The effective element width - this is encoded in the …","The width of the elements being accessed from memory","The width of the elements being accessed. This doesn’t …","The width of the elements being accessed from memory","The effective LMUL of the operation, e.g. the size of the …","The effective LMUL of the elements being accessed from …","The effective LMUL of the operation. See […","The effective vector length - always equal to the current …","The effective vector length - always equal to the current …","The number of bytes to load, i.e. <code>ceil(vl/8)</code>","The effective vector length - always equal to the current …","The effective LMUL for the indices.","The width of the indices. Indices are byte offsets.","Number of Fields for segmented access","Number of Fields for segmented access","Number of Fields for segmented access","The number of registers to load or store. Encoded the …","Whether elements must be accessed in the order specified …","The stride, specified in bytes TODO make this signed …","","Register file which holds 128-bit integer vectors OR one …","Register file which holds 128-bit integer vectors.","Trait for a vector register file where VLEN=128, ELEN=128.…","Returns (register idx, bit range) for an element of a …","","","","","","","","","","Complementary function to [replace_bits]","","","","","","","","Load a value from an element in a vertex register group, …","","","","","","","","","Function that replaces the bits of a value in a specific …","","","","Returns true if the mask is enabled and element <code>i</code> has …","","","","","","Store a value in an element in a vertex register group, …","","","","","","","","","","","","","","","","","Config instruction kind enum","Length-Mul enum","Selected-Element-Width enum","Vector register length in bits","Vector type information","A struct describing an element of a vector register group","The first register of the group. Should be a multiple of …","","","","","","","","","","","","","","","","","","","Attempt to decode a u32 vtype value (e.g. one encoded in …","","On CHERI, used to load/store capabilities.","","","","","","","","","","","The element width,","The index of the element within the group","Shorthand for [VType::val_times_lmul_over_sew] with x = …","Encode the VType structure into a u32 This is necessary …","","","","","","","","","","","","","Generate a VType with the illegal bit <code>vill</code> set, and all …","","","","","","","Returns the number of vector registers a group actually …","","","","","","","","","","","","","","","","","","","Unsigned type of length [VLEN]","Function that evaluates (X * LMUL) / SEW from their enum …","Function that evaluates (X * LMUL) / SEW from their enum …","Illegal value.","Length multiplier. See [Lmul]","Vector mask agnostic.","","","","Selected element width. See [Sew]","Vector tail agnostic.","","","","","","RISC-V Processor Model where XLEN=32-bit. No CHERI …","","RISC-V Processor Model where XLEN=64-bit. No CHERI …","","RISC-V Processor Model where XLEN=64-bit, with CHERI …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","RISC-V Processor Model where XLEN=32-bit. No CHERI …","","","","","","","","","","","","","Dump processor and vector unit state to standard output.","Run a fetch-decode-execute step on the processor, …","","","","","","","","","","Create a new processor and vector unit which operates on …","","Process an instruction, returning the new PC value or any …","Reset the processor and associated vector unit","","","","","","","","","","","","","","","","","","RISC-V Processor Model where XLEN=64-bit. No CHERI …","","","","","","","","","","","","","Dump processor and vector unit state to standard output.","Run a fetch-decode-execute step on the processor, …","","","","","","","","","","Create a new processor and vector unit which operates on …","","Process an instruction, returning the new PC value or any …","Reset the processor and associated vector unit","","","","","","","","","","","","","","","","","","","","","RISC-V Processor Model where XLEN=64-bit, with CHERI …","","","","","","","","","","","","","","","","","","Dump processor and vector unit state to standard output.","","Run a fetch-decode-execute step on the processor, …","","","","","","","","","","","","","","","Create a new processor and vector unit which operates on …","","Process an instruction, returning the new PC value or any …","Reset the processor and associated vector unit","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[1,2,2,2,2,0,0,0,0,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,3,3,3,1,3,1,3,1,3,1,3,1,3,3,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,2,3,2,3,2,3,3,2,3,2,3,1,3,1,3,1,3,0,0,2,3,2,3,2,3,2,3,2,3,2,3,1,3,3,3,3,3,2,3,1,3,1,3,1,3,1,3,1,3,0,4,4,0,0,0,0,0,5,6,5,5,6,6,0,0,6,5,5,5,5,5,5,5,5,5,5,0,6,6,6,5,5,5,6,6,5,5,7,6,5,7,6,5,7,6,5,7,6,7,0,5,5,7,6,5,7,6,6,6,6,6,6,6,6,6,6,6,5,7,6,7,7,7,7,7,7,7,5,7,6,5,7,6,5,7,6,5,7,6,7,8,9,10,11,12,13,13,8,10,14,9,10,11,15,16,12,14,14,14,8,9,10,15,16,13,14,8,9,10,11,12,13,14,8,10,11,12,13,14,13,14,14,13,13,0,0,0,1,2,2,2,2,0,0,0,0,0,0,0,1,1,2,0,0,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,17,0,0,17,18,19,4,18,19,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,20,2,2,1,1,1,0,0,21,2,2,2,2,2,2,1,4,2,1,1,1,1,1,22,22,1,2,2,2,2,0,0,0,0,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,17,0,17,17,17,0,0,0,0,17,17,1,1,1,1,17,17,1,17,17,17,17,17,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,17,2,2,1,1,1,17,2,2,2,2,2,2,1,17,17,17,17,17,17,2,17,1,1,1,1,1,22,22,0,0,0,0,4,18,18,4,18,20,4,18,20,4,18,4,20,4,18,4,4,4,20,20,4,18,4,18,23,23,20,20,4,18,20,4,4,18,23,23,23,23,4,18,4,20,4,18,20,4,18,20,4,18,18,20,4,4,18,0,0,19,19,21,19,21,19,21,19,21,19,21,21,21,19,21,19,21,19,21,21,19,19,21,21,21,21,21,19,21,19,21,19,21,19,21,19,19,21,21,19,21,21,0,0,0,0,0,0,24,25,26,27,25,26,27,25,26,27,0,26,25,26,27,27,26,27,26,27,27,25,25,26,27,27,24,24,24,24,27,24,25,26,27,25,26,28,25,26,26,26,26,27,25,27,24,24,24,24,25,26,27,25,26,27,25,26,27,25,28,25,26,26,26,26,27,26,29,0,0,0,30,29,30,29,30,30,29,29,30,30,29,29,29,30,29,30,30,29,29,31,30,30,30,30,30,29,29,30,29,30,29,30,29,31,30,32,32,33,34,0,0,0,33,32,33,0,35,33,0,0,34,36,33,33,35,35,35,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,35,35,32,32,36,36,34,33,33,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,35,32,36,33,35,32,36,34,33,35,32,36,34,33,35,32,36,34,33,37,38,39,40,37,41,42,42,38,37,43,44,45,43,44,46,0,0,0,0,47,0,0,0,0,0,0,0,0,0,0,0,0,0,48,48,0,49,49,49,0,50,47,48,49,48,48,50,50,48,50,0,0,48,50,48,48,48,0,51,52,47,0,0,0,50,53,54,50,53,54,50,53,54,50,53,54,53,50,53,54,50,50,50,50,50,53,54,50,53,54,50,53,54,53,54,0,0,0,0,0,0,0,55,56,55,56,55,49,49,49,56,55,55,56,55,49,56,55,56,56,56,55,56,55,56,55,55,0,57,57,57,57,57,57,57,57,57,0,58,58,58,58,58,58,58,58,58,59,60,61,0,0,0,60,59,59,0,0,60,62,0,0,0,0,0,0,0,61,62,59,0,0,0,0,0,0,0,0,0,60,61,59,63,64,63,63,65,65,0,63,63,63,0,66,63,67,68,68,67,68,67,68,68,67,67,67,67,64,64,63,63,63,0,63,63,63,65,63,63,63,69,63,66,66,66,66,63,0,0,66,63,66,65,65,63,69,66,66,66,66,63,63,63,0,0,0,70,63,70,70,51,52,63,71,71,71,70,63,70,63,63,72,73,74,75,72,73,74,76,72,73,76,72,73,75,76,73,73,72,73,76,74,73,72,0,0,0,65,65,65,69,65,65,69,59,60,61,0,60,59,77,59,60,62,0,0,61,62,77,59,77,0,0,60,61,59,59,77,60,61,62,59,77,60,61,62,59,77,60,61,62,59,77,60,61,62,59,59,59,77,60,61,62,59,59,77,60,61,62,59,77,60,61,62,59,77,60,61,62,59,77,59,77,60,61,62,59,77,60,61,62,59,77,60,61,62,59,77,60,61,62,59,72,73,74,75,72,73,74,76,72,73,76,72,73,75,76,73,73,72,73,76,74,73,72,78,0,0,0,0,51,52,51,52,51,52,66,51,52,0,51,52,51,52,66,51,52,66,51,52,66,51,52,66,51,52,0,66,51,52,66,51,52,66,51,52,66,51,52,66,51,52,66,51,52,51,52,51,52,51,52,51,52,0,0,0,0,0,0,64,71,70,68,67,64,71,70,68,67,64,64,64,70,68,67,70,68,67,70,67,68,68,67,68,67,68,68,67,67,67,67,64,64,70,70,70,68,67,70,68,67,64,71,70,68,67,64,70,71,70,68,67,64,70,67,70,68,67,71,70,68,67,64,71,70,68,67,64,71,70,68,67,64,0,0,70,70,70,70,71,71,71,70,70,68,79,0,79,0,0,0,0,0,0,0,80,81,82,82,83,83,83,82,82,80,81,82,80,81,82,83,83,80,81,82,84,0,85,86,86,0,0,84,85,86,80,81,82,82,86,84,85,86,0,0,0,80,84,87,80,84,87,87,87,87,80,80,80,80,84,87,80,87,80,84,87,80,80,80,80,80,80,80,84,80,84,80,80,84,87,80,84,87,80,84,87,84,80,0,0,0,81,85,88,81,85,88,88,88,88,81,81,81,81,85,88,81,88,81,85,88,81,81,81,81,81,81,81,85,81,85,81,81,85,88,81,85,88,81,85,88,85,81,79,0,79,0,0,0,82,86,89,79,82,86,89,79,79,79,89,89,89,82,82,82,79,82,79,82,86,89,79,82,89,82,82,86,89,79,82,82,82,82,82,82,82,82,86,86,86,82,82,79,82,86,89,79,82,86,89,79,82,86,89,79,86,82,86,82],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["cc128",4]],[[]],[[["ccxcap",3]]],[[["ccxcap",3]],["u64",15]],[[["ccxcap",3]]],[[["ccxcap",3]],["u64",15]],[[["bool",15]],["ccxcap",3]],[[["bool",15],["u64",15]],[["cc128",4],["ccxcap",3]]],[[["bool",15]],["ccxcap",3]],[[["bool",15],["u64",15]],[["cc128",4],["ccxcap",3]]],[[],["ccxboundsbits",3]],[[],["ccxboundsbits",3]],[[["formatter",3]],[["error",3],["result",4]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[["bool",15]],["bool",15]],[[],["ccxcap",3]],[[],[["cc128",4],["ccxcap",3]]],null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["bool",15]],[[["ccxcap",3]],["bool",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],[[]],[[["ccxcap",3],["u8",15]]],[[["u8",15],["ccxcap",3]]],[[["ccxcap",3],["u32",15]]],[[["u32",15],["ccxcap",3]]],[[["ccxcap",3],["u32",15]]],[[["u32",15],["ccxcap",3]]],[[["ccxcap",3],["u8",15]]],[[["u8",15],["ccxcap",3]]],[[["ccxcap",3],["u32",15]]],[[["u32",15],["ccxcap",3]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[],["opcode",4]],[[],["imm",3]],[[],["instructionbits",4]],[[]],[[]],[[]],null,[[["u32",15]],["result",6]],[[["opcode",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],["instructionbits",4]],[[["u32",15]],[["opcode",4],["result",6]]],[[]],[[]],[[]],[[["u32",15]],["imm",3]],[[],["u32",15]],[[],["u64",15]],[[],["i32",15]],[[],["i64",15]],[[],["u32",15]],[[],["u64",15]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["cc128cap",6]],[["u64",15],["range",3]]],null,[[["cc128cap",6],["u32",15],["u64",15],["range",3]],["result",6]],[[["u32",15],["cc128cap",6]],["result",6]],[[["u32",15],["u64",15],["cc128cap",6]],["result",6]],[[["ccxcap",3]]],[[["ccxcap",3]]],[[["bool",15]],["ccxcap",3]],[[["bool",15]],["ccxcap",3]],[[],["ccxboundsbits",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[],["bool",15]],[[],["bool",15]],[[]],null,[[]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[],["ccxcap",3]],null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["bool",15]],null,[[]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[["cc128cap",6]],[["u64",15],["range",3]]],[[["cc128cap",6],["u32",15],["u64",15],["range",3]],["result",6]],[[["u32",15],["cc128cap",6]],["result",6]],[[["u32",15],["u64",15],["cc128cap",6]],["result",6]],[[],["safetaggedcap",4]],[[]],[[["ccxcap",3]]],[[["ccxcap",3]]],[[["bool",15]],["ccxcap",3]],[[["bool",15]],["ccxcap",3]],[[]],[[["safetaggedcap",4]],["bool",15]],[[],["ccxboundsbits",3]],[[["formatter",3]],["result",6]],[[]],[[["cc128cap",6]]],[[["u128",15]]],[[["bool",15],["u64",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[],["ccxcap",3]],[[["safetaggedcap",4]],["bool",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["bool",15]],[[],["cc128cap",6]],[[],["u128",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],[[],["cc128cap",6]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],null,null,null,null,null,null,[[],["any",8]],[[],["any",8]],null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["cc128cap",6]],[["memoryresult",6],["u32",15]]],[[]],[[]],[[]],[[["aggregatememory",3]],["cheriaggregatememory",3]],[[],["cc128cap",6]],[[],[["option",4],["vec",3]]],null,[[]],[[]],[[]],[[["sew",4]],[["safetaggedcap",4],["result",6]]],[[["sew",4]],[["safetaggedcap",4],["result",6]]],[[],[["memoryresult",6],["safetaggedcap",4]]],[[],[["memoryresult",6],["safetaggedcap",4]]],[[]],[[],[["usize",15],["range",3]]],[[],[["usize",15],["range",3]]],[[],[["usize",15],["range",3]]],[[["u64",15]],[["memoryresult",6],["bool",15]]],[[["cc128cap",6]],["memoryresult",6]],[[["cc128cap",6]],[["memoryresult",6],["safetaggedcap",4]]],[[["u64",15]],["memoryresult",6]],[[["cc128cap",6]],["memoryresult",6]],[[["cc128cap",6]],["memoryresult",6]],[[["safetaggedcap",4]],["memoryresult",6]],[[["safetaggedcap",4]],["memoryresult",6]],[[["safetaggedcap",4],["sew",4]],["result",6]],[[["safetaggedcap",4],["sew",4]],["result",6]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[["cheriaggregatememory",3],["cc128cap",6]]],[[["bool",15],["u64",15]],["memoryresult",6]],[[["cc128cap",6]],["memoryresult",6]],[[["safetaggedcap",4],["cc128cap",6]],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],null,null,null,null,[[]],[[]],[[]],[[]],[[["memopdir",4],["provenance",6],["u64",15],["range",3]],["result",6]],[[["memopdir",4],["provenance",6],["u64",15],["range",3]],["result",6]],[[["sew",4],["memopdir",4]],["result",6]],[[["sew",4],["memopdir",4]],["result",6]],[[]],[[]],[[]],[[]],[[["u8",15]],["result",6]],[[["u8",15]],["result",6]],[[]],[[]],[[["u8",15]],[["result",4],["u64",15],["registerfileerror",4]]],[[["u8",15]],[["safetaggedcap",4],["result",4],["registerfileerror",4]]],[[["u8",15]],[["result",4],["u64",15],["registerfileerror",4]]],[[["u8",15]],[["result",6],["cc128cap",6]]],[[["u8",15]],[["safetaggedcap",4],["result",4],["registerfileerror",4]]],[[["u8",15]],[["result",4],["u64",15],["registerfileerror",4]]],null,[[]],[[["u8",15]],[["result",6],["u64",15]]],[[["u8",15]],[["result",6],["u64",15]]],[[["u8",15],["u64",15]],["result",6]],[[["u8",15],["u64",15]],["result",6]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[["cc128cap",6],["cherirv64registerfile",3]]],[[["u8",15],["u64",15]],[["registerfileerror",4],["result",4]]],[[["safetaggedcap",4],["u8",15]],[["registerfileerror",4],["result",4]]],[[["u8",15],["u64",15]],[["registerfileerror",4],["result",4]]],[[["safetaggedcap",4],["u8",15]],[["registerfileerror",4],["result",4]]],[[["u8",15],["u64",15]],[["registerfileerror",4],["result",4]]],null,null,null,null,null,null,[[],["any",8]],[[],["any",8]],[[],["any",8]],[[],["any",8]],[[]],[[]],[[]],[[]],[[]],[[]],[[["u64",15],["range",3]],["memoryresult",6]],null,[[]],[[]],[[["memorybacking",3]]],[[]],[[["usize",15],["str",15],["range",3]],["memorybacking",3]],[[["vec",3],["box",3]]],[[["range",3],["usize",15],["u8",15],["vec",3]],["memorybacking",3]],null,[[],[["option",4],["vec",3]]],null,[[]],[[]],[[]],[[["sew",4]],[["u128",15],["result",6]]],[[],[["memoryresult",6],["u16",15]]],[[],[["memoryresult",6],["u32",15]]],[[],[["memoryresult",6],["u64",15]]],[[],[["u8",15],["memoryresult",6]]],null,[[],[["usize",15],["range",3]]],[[],[["usize",15],["range",3]]],[[],[["usize",15],["range",3]]],[[],[["usize",15],["range",3]]],null,null,[[],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],[[["u64",15]],[["u8",15],["memoryresult",6]]],[[["u64",15]],[["memoryresult",6],["u32",15]]],[[["u64",15]],[["memoryresult",6],["u64",15]]],[[["u64",15]],[["memoryresult",6],["u16",15]]],[[["u64",15]],["memoryresult",6]],[[["usize",15],["bool",15]],["iomemory",3]],[[["u128",15],["sew",4]],["result",6]],[[["u16",15]],["memoryresult",6]],[[["u32",15]],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],[[["u8",15]],["memoryresult",6]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],[[["u32",15],["u64",15]],["memoryresult",6]],[[["u64",15],["u8",15]],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],[[["u64",15],["u16",15]],["memoryresult",6]],[[["u64",15]],["memoryresult",6]],[[["usize",15],["range",3]],["memorybacking",3]],null,null,null,null,[[]],[[]],[[]],[[]],[[["memopdir",4],["provenance",6],["u64",15],["range",3]],["result",6]],[[["sew",4],["memopdir",4]],["result",6]],[[],["registerfileerror",4]],[[]],[[]],[[]],[[["registerfileerror",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[["u8",15]],["result",6]],[[]],[[]],[[["registerfileerror",4]],["bool",15]],[[["u8",15]],[["registerfileerror",4],["result",4]]],[[["u8",15]],[["registerfileerror",4],["result",4]]],null,[[]],[[["u8",15]],["result",6]],[[["u8",15]],["result",6]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[["u8",15]],[["registerfileerror",4],["result",4]]],[[["u8",15]],[["registerfileerror",4],["result",4]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["illegalinstructionexception",4]],[[],["memoryexception",4]],[[],["programhaltedexception",4]],[[],["caporregister",4]],[[],["capabilityexception",4]],[[]],[[]],[[]],[[]],[[]],[[["illegalinstructionexception",4]],["bool",15]],[[["memoryexception",4]],["bool",15]],[[["programhaltedexception",4]],["bool",15]],[[["caporregister",4]],["bool",15]],[[["capabilityexception",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["illegalinstructionexception",4]],["bool",15]],[[["memoryexception",4]],["bool",15]],[[["programhaltedexception",4]],["bool",15]],[[["caporregister",4]],["bool",15]],[[["capabilityexception",4]],["bool",15]],[[]],[[]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],null,[[["option",4],["u32",15]],["processorresult",6]],[[["option",4],["u32",15]],["processorresult",6]],[[["u32",15],["bool",15]],[["option",4],["processorresult",6]]],null,null,[[["opcode",4],["instructionbits",4],["u32",15]],[["processorresult",6],["option",4]]],[[]],[[["u32",15]],["bool",15]],[[]],null,null,null,null,null,null,null,null,null,[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,[[["opcode",4],["instructionbits",4]],["bool",15]],null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],null,[[["opcode",4],["instructionbits",4],["u32",15],["xcheri64conn",3]],[["processorresult",6],["option",4]]],[[["opcode",4],["instructionbits",4],["u32",15],["xcheri64conn",3]],[["processorresult",6],["option",4]]],[[]],[[]],[[]],[[["xcheri64conn",3],["u8",15],["u64",15]],[["processorresult",6],["cc128cap",6]]],[[]],[[]],[[]],null,null,null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[["opcode",4],["instructionbits",4]],["bool",15]],[[["opcode",4],["instructionbits",4]],["bool",15]],null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[["option",4],["u32",15]],["processorresult",6]],[[["option",4],["u32",15]],["processorresult",6]],[[["u32",15],["bool",15]],[["option",4],["processorresult",6]]],null,[[]],[[["opcode",4],["zicsrconn",3],["instructionbits",4],["u32",15]],[["processorresult",6],["option",4]]],[[]],[[]],[[["u32",15]],["bool",15]],[[]],[[]],[[["u32",15]],[["option",4],["csrprovider",8]]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[["opcode",4],["instructionbits",4]],["bool",15]],null,[[]],[[]],[[["opcode",4],["rv32imconn",6],["instructionbits",4],["u32",15]],[["processorresult",6],["option",4]]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["opcode",4],["instructionbits",4]],["bool",15]],null,[[]],[[]],[[["opcode",4],["instructionbits",4],["u32",15],["rv64imconn",6]],[["processorresult",6],["option",4]]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["opcode",4],["instructionbits",4]],["bool",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[["memopdir",4],["provenance",6],["u64",15],["range",3]],["result",6]],[[["sew",4],["memopdir",4]],["result",6]],null,[[["option",4],["u32",15]],["result",6]],[[["option",4],["u32",15]],["result",6]],[[["u32",15],["bool",15]],[["result",6],["option",4]]],null,[[]],[[]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["instructionbits",4],["vecreginterface",8],["configkind",4]],["result",6]],[[["range",3],["bool",15],["vecreginterface",8],["vecmeminterface",8],["decodedmemop",4],["u8",15],["u64",15]],["result",6]],[[["opcode",4],["instructionbits",4],["u32",15],["vecinterface",6]],[["option",4],["processorresult",6]]],[[["u128",15],["usize",15],["range",3]],["u128",15]],[[["bool",15],["vecreginterface",8],["decodedmemop",4],["u8",15]]],[[]],[[["bool",15],["u32",15]],[["option",4],["range",3]]],[[["u8",15]],["result",6]],[[["decodedmemop",4],["bool",15],["u8",15]],[["vec",3],["result",6]]],[[["u32",15]],["bool",15]],[[]],[[["sew",4]],["result",6]],[[["vecmeminterface",8],["u32",15],["u8",15],["sew",4]],["result",6]],[[["u8",15]],["result",6]],[[["u32",15],["sew",4],["u8",15]],["result",6]],[[["u32",15],["sew",4],["u8",15]],[["u128",15],["result",6]]],[[["u8",15]],[["u128",15],["result",6]]],[[["box",3],["vectorregisterfile",8]]],null,[[["u128",15],["usize",15],["range",3]],["u128",15]],[[]],[[]],[[["bool",15],["u32",15]],["bool",15]],[[["u8",15]],["result",6]],[[["u8",15]],["result",6]],[[["vecmeminterface",8],["u32",15],["u8",15],["sew",4]],["result",6]],[[["sew",4]],["result",6]],[[["u8",15]],["result",6]],[[["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u8",15]],["result",6]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,[[["u32",15],["sew",4],["lmul",4]],["u32",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["opcode",4],["instructionbits",4]],["bool",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["memopdir",4],["provenance",6],["u64",15],["range",3]],["result",6]],[[["sew",4],["memopdir",4]],["result",6]],[[["u8",15]],["result",6]],[[["sew",4]],["result",6]],[[["u8",15]],["result",6]],[[["u8",15]],["result",6]],[[["sew",4]],["result",6]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["instructionbits",4],["vtype",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["rvvmoptype",4]],[[],["unitstrideloadop",4]],[[],["unitstridestoreop",4]],[[],["memopdir",4]],[[],["decodedmemop",4]],[[]],[[]],[[]],[[]],[[]],[[["opcode",4],["vecreginterface",8],["instructionbits",4],["u32",15],["vtype",3]],[["decodedmemop",4],["result",6]]],[[],["memopdir",4]],[[["rvvmoptype",4]],["bool",15]],[[["unitstrideloadop",4]],["bool",15]],[[["unitstridestoreop",4]],["bool",15]],[[["memopdir",4]],["bool",15]],[[["decodedmemop",4]],["bool",15]],[[],["u32",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["rvvmoptype",4]],["bool",15]],[[["decodedmemop",4]],["bool",15]],[[]],[[]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["u32",15],["sew",4],["u8",15]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["u128",15],["usize",15],["range",3]],["u128",15]],[[]],[[]],[[]],[[]],[[["u8",15]],["result",6]],[[["u8",15]],[["u128",15],["result",6]]],[[["u8",15]],[["safetaggedcap",4],["result",6]]],[[["u32",15],["sew",4],["u8",15]],["result",6]],[[["u32",15],["sew",4],["u8",15]],[["u128",15],["result",6]]],[[["u32",15],["sew",4],["u8",15]],[["safetaggedcap",4],["result",6]]],[[["u32",15],["sew",4],["u8",15]],[["u128",15],["result",6]]],[[["u32",15],["sew",4],["u8",15]],[["u128",15],["result",6]]],[[["u32",15],["sew",4],["u8",15]],[["u128",15],["result",6]]],[[["u8",15]],[["u128",15],["result",6]]],[[["u8",15]],[["u128",15],["result",6]]],[[["u8",15]],[["u128",15],["result",6]]],[[["u128",15],["usize",15],["range",3]],["u128",15]],[[]],[[]],[[]],[[["bool",15],["u32",15]],["bool",15]],[[["bool",15],["u32",15]],["bool",15]],[[["bool",15],["u32",15]],["bool",15]],[[["u8",15]],["result",6]],[[["u128",15],["u8",15]],["result",6]],[[["safetaggedcap",4],["u8",15]],["result",6]],[[["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u32",15],["sew",4],["u8",15]],["result",6]],[[["safetaggedcap",4],["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u32",15],["sew",4],["u8",15]],["result",6]],[[["u128",15],["u8",15]],["result",6]],[[["u128",15],["u8",15]],["result",6]],[[["u128",15],["u8",15]],["result",6]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["lmul",4],["u32",15],["u8",15],["sew",4]],["vectorelem",3]],[[["u32",15],["u8",15],["sew",4]],["vectorelem",3]],[[],["vtype",3]],[[],["sew",4]],[[],["lmul",4]],[[]],[[]],[[]],[[["u32",15]],[["vtype",3],["result",6]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["u32",15]],[[],["u32",15]],[[["vtype",3]],["bool",15]],[[["sew",4]],["bool",15]],[[["lmul",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["vtype",3]],["bool",15]],[[],["u8",15]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[["u32",15],["sew",4],["lmul",4]],["u32",15]],[[["u32",15]],["u32",15]],null,null,null,null,null,null,null,null,[[],["u64",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[],["result",6]],[[],[["option",4],["vec",3]]],null,null,null,null,null,null,null,null,[[]],[[],["bool",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["u32",15],["option",4]],[["result",6],["u32",15]]],[[["u32",15],["option",4]],[["result",6],["u32",15]]],[[["u32",15],["bool",15]],[["option",4],["result",6]]],null,[[["processormodules32",3]]],[[["processormodules32",3]],["result",6]],[[]],[[]],[[]],[[],[["option",4],["vec",3]]],[[["u32",15]],["bool",15]],[[]],[[]],[[]],null,[[["aggregatememory",3]]],null,[[["opcode",4],["instructionbits",4],["processormodules32",3],["u32",15]],[["result",6],["u32",15]]],[[["processormodules32",3]]],[[],["bool",15]],null,null,[[],["rv32imconn",6]],null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[["option",4]],["zicsr32conn",6]],null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["u32",15],["option",4],["u64",15]],[["result",6],["u64",15]]],[[["u32",15],["option",4],["u64",15]],[["result",6],["u64",15]]],[[["u32",15],["bool",15],["u64",15]],[["result",6],["option",4]]],null,[[["rv64imvprocessormodules",3]]],[[["rv64imvprocessormodules",3]],["result",6]],[[]],[[]],[[]],[[],[["option",4],["vec",3]]],[[["u32",15]],["bool",15]],[[]],[[]],[[]],null,[[["aggregatememory",3]]],null,[[["opcode",4],["instructionbits",4],["rv64imvprocessormodules",3],["u32",15]],[["result",6],["u64",15]]],[[["rv64imvprocessormodules",3]]],[[],["bool",15]],null,null,[[],["rv64imconn",6]],null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[["option",4]],["zicsr64conn",6]],null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["cheriexecmode",4]],[[]],[[["u32",15],["option",4],["u64",15]],[["result",6],["u64",15]]],[[["u32",15],["option",4],["u64",15]],[["result",6],["u64",15]]],[[["u32",15],["bool",15],["u64",15]],[["result",6],["option",4]]],null,null,[[["rv64imvxcheriprocessormodules",3]]],[[["cheriexecmode",4]],["bool",15]],[[["rv64imvxcheriprocessormodules",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[],[["option",4],["vec",3]]],[[["u32",15]],["bool",15]],null,[[]],[[]],[[]],[[]],null,null,[[["cheriaggregatememory",3],["u64",15],["cheriexecmode",4]]],null,[[["opcode",4],["rv64imvxcheriprocessormodules",3],["u32",15],["instructionbits",4]],[["cc128cap",6],["result",6]]],[[["rv64imvxcheriprocessormodules",3]]],[[],["bool",15]],null,null,null,null,null,null,[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[["cheriexecmode",4]],["xcheri64conn",3]],null,[[["rv64cheriv",6]],["zicsr64conn",6]]],"p":[[8,"CompressedCapability"],[8,"CheriRVFuncs"],[4,"Cc128"],[3,"CheriAggregateMemory"],[4,"Opcode"],[4,"InstructionBits"],[3,"Imm"],[13,"RType"],[13,"IType"],[13,"ROrIType"],[13,"SType"],[13,"BType"],[13,"VType"],[13,"FLdStType"],[13,"UType"],[13,"JType"],[4,"SafeTaggedCap"],[3,"IntegerModeCheriAggregateMemory"],[3,"IntegerModeCheriRV64RegisterFile"],[3,"TagMemory"],[3,"CheriRV64RegisterFile"],[13,"RawData"],[8,"CheriMemory"],[8,"Memory"],[3,"IOMemory"],[3,"MemoryBacking"],[3,"AggregateMemory"],[8,"MemoryOf"],[4,"RegisterFileError"],[3,"RvRegisterFile"],[8,"RegisterFile"],[4,"MemoryException"],[4,"CapabilityException"],[4,"CapOrRegister"],[4,"IllegalInstructionException"],[4,"ProgramHaltedException"],[13,"LengthViolation"],[13,"BoundsViolation"],[13,"TagViolation"],[13,"SealViolation"],[13,"InexactBounds"],[13,"PermissionViolation"],[13,"AddressMisaligned"],[13,"JumpMisaligned"],[13,"AddressUnmapped"],[13,"ResultReturned"],[8,"IsaMod"],[3,"RvimConn"],[8,"CSRProvider"],[3,"XCheri64Conn"],[3,"IntVectorRegisterFile"],[3,"CheriVectorRegisterFile"],[3,"XCheri64"],[3,"Rv64imCapabilityMode"],[3,"Zicsr"],[3,"ZicsrConn"],[3,"Rv32im"],[3,"Rv64im"],[4,"DecodedMemOp"],[4,"UnitStrideLoadOp"],[4,"UnitStrideStoreOp"],[4,"MemOpDir"],[3,"Rvv"],[3,"VectorElem"],[8,"VecRegInterface"],[8,"VectorRegisterFile"],[4,"Lmul"],[4,"Sew"],[8,"VecMemInterface"],[3,"VType"],[4,"ConfigKind"],[13,"Strided"],[13,"Indexed"],[13,"WholeRegister"],[13,"ByteMask"],[13,"FaultOnlyFirst"],[4,"RvvMopType"],[13,"Indexed"],[4,"CheriExecMode"],[3,"Processor32"],[3,"Rv64imvProcessor"],[3,"Rv64imvXCheriProcessor"],[8,"Processor"],[3,"ProcessorModules32"],[3,"Rv64imvProcessorModules"],[3,"Rv64imvXCheriProcessorModules"],[3,"ProcessorCSRs32"],[3,"Rv64imvProcessorCSRs"],[3,"Rv64imvXCheriProcessorCSRs"]]},\
"rust_cheri_compressed_cap":{"doc":"","t":[16,4,6,4,6,3,3,8,16,8,16,16,18,18,8,18,18,18,18,16,18,18,18,18,18,18,18,18,18,18,18,18,12,12,11,12,11,11,11,11,11,11,0,0,0,11,11,10,10,12,12,12,12,12,12,10,10,11,12,11,10,11,11,11,11,10,10,10,10,10,10,10,10,12,11,11,11,10,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,10,10,10,10,10,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,4,6,6,6,6,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,6,4,6,6,6,6,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,16,16,16,16,8,16,16,16,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],"n":["Addr","Cc128","Cc128Cap","Cc64","Cc64Cap","CcxBoundsBits","CcxCap","CompressedCapability","FfiLength","FfiNumType","FfiOffset","Length","MAX_REPRESENTABLE_OTYPE","MAX_UNRESERVED_OTYPE","NumType","OTYPE_RESERVED2","OTYPE_RESERVED3","OTYPE_SENTRY","OTYPE_UNSEALED","Offset","PERM_ACCESS_SYS_REGS","PERM_CINVOKE","PERM_EXECUTE","PERM_GLOBAL","PERM_LOAD","PERM_LOAD_CAP","PERM_SEAL","PERM_SETCID","PERM_STORE","PERM_STORE_CAP","PERM_STORE_LOCAL","PERM_UNSEAL","_cr_cursor","_cr_top","address","b","base","borrow","borrow","borrow_mut","borrow_mut","bounds","c_funcs","cc128","cc64","clone","clone_into","compress_mem","compress_raw","cr_base","cr_bounds_valid","cr_exp","cr_extra","cr_pesbt","cr_tag","decompress_mem","decompress_raw","default","e","eq","extract_bounds_bits","flags","fmt","from","from","get_alignment_mask","get_flags","get_otype","get_perms","get_representable_length","get_required_alignment","get_reserved","get_uperms","ie","into","into","is_exact","is_representable_cap_exact","is_representable_new_addr","is_representable_with_new_addr","is_sealed","length","make_max_perms_cap","mem_representation","offset","otype","permissions","reg_representation","reserved_bits","set_address_unchecked","set_bounds","set_bounds_unchecked","set_flags","set_otype","set_permissions","set_reserved_bits","set_software_permissions","set_tag","software_permissions","t","tag","to_owned","top","try_from","try_from","try_into","try_into","type_id","type_id","update_flags","update_otype","update_perms","update_reserved","update_uperms","wrappers","cc128_compress_mem","cc128_compress_raw","cc128_decompress_mem","cc128_decompress_raw","cc128_extract_bounds_bits","cc128_get_alignment_mask","cc128_get_flags","cc128_get_otype","cc128_get_perms","cc128_get_representable_length","cc128_get_required_alignment","cc128_get_reserved","cc128_get_uperms","cc128_is_representable_cap_exact","cc128_is_representable_new_addr","cc128_make_max_perms_cap","cc128_setbounds","cc128_update_flags","cc128_update_otype","cc128_update_perms","cc128_update_reserved","cc128_update_uperms","cc64_compress_mem","cc64_compress_raw","cc64_decompress_mem","cc64_decompress_raw","cc64_extract_bounds_bits","cc64_get_alignment_mask","cc64_get_flags","cc64_get_otype","cc64_get_perms","cc64_get_representable_length","cc64_get_required_alignment","cc64_get_reserved","cc64_get_uperms","cc64_is_representable_cap_exact","cc64_is_representable_new_addr","cc64_make_max_perms_cap","cc64_setbounds","cc64_update_flags","cc64_update_otype","cc64_update_perms","cc64_update_reserved","cc64_update_uperms","Addr","Cap","Cc128","Cc128Cap","FfiLength","FfiOffset","Length","Offset","borrow","borrow_mut","clone","clone_into","compress_mem","compress_raw","decompress_mem","decompress_raw","extract_bounds_bits","fmt","from","getCapBaseBits","getCapBounds","getCapCursor","getCapFlags","getCapLength","getCapOffsetBits","getCapPerms","getCapTop","getRepresentableAlignmentMask","getRepresentableLength","get_alignment_mask","get_flags","get_otype","get_perms","get_representable_length","get_required_alignment","get_reserved","get_uperms","hasReservedOType","inCapBounds","incCapOffset","into","invalidateCap","isCapSealed","is_representable_cap_exact","is_representable_new_addr","make_max_perms_cap","sealCap","setCapAddr","setCapBounds","setCapFlags","setCapOffset","setCapPerms","set_bounds","to_owned","try_from","try_into","type_id","unsealCap","update_flags","update_otype","update_perms","update_reserved","update_uperms","Addr","Cap","Cc64","Cc64Cap","FfiLength","FfiOffset","Length","Offset","borrow","borrow_mut","clone","clone_into","compress_mem","compress_raw","decompress_mem","decompress_raw","extract_bounds_bits","fmt","from","getCapBaseBits","getCapBounds","getCapCursor","getCapFlags","getCapLength","getCapOffsetBits","getCapPerms","getCapTop","getRepresentableAlignmentMask","getRepresentableLength","get_alignment_mask","get_flags","get_otype","get_perms","get_representable_length","get_required_alignment","get_reserved","get_uperms","hasReservedOType","inCapBounds","incCapOffset","into","invalidateCap","isCapSealed","is_representable_cap_exact","is_representable_new_addr","make_max_perms_cap","sealCap","setCapAddr","setCapBounds","setCapFlags","setCapOffset","setCapPerms","set_bounds","to_owned","try_from","try_into","type_id","unsealCap","update_flags","update_otype","update_perms","update_reserved","update_uperms","Cap","CapAddrBits","CapAddrInt","CapLen","CheriRVFuncs","Flags","OType","Perms","getCapBaseBits","getCapBounds","getCapCursor","getCapFlags","getCapLength","getCapOffsetBits","getCapPerms","getCapTop","getRepresentableAlignmentMask","getRepresentableLength","hasReservedOType","inCapBounds","incCapOffset","invalidateCap","isCapSealed","sealCap","setCapAddr","setCapBounds","setCapFlags","setCapOffset","setCapPerms","unsealCap"],"q":["rust_cheri_compressed_cap","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rust_cheri_compressed_cap::c_funcs","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rust_cheri_compressed_cap::cc128","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rust_cheri_compressed_cap::cc64","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","rust_cheri_compressed_cap::wrappers","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["ccx_addr_t equivalent","Defines the CC128 capability profile as an implementation …","","Defines the CC64 capability profile as an implementation …","","Structure matching the C type <code>_cc_N(bounds_bits)</code>. …","Structure matching the C type <code>_cc_N(cap)</code>. Field order and …","Trait defining an Rust version of the public API for a …","ccx_length_t C-land equivalent - should have a memory …","Value which can be converted to T (a NumType). Must also …","ccx_offset_t C-land equivalent - should have a memory …","ccx_length_t Rust-land equivalent - should be a superset …","","","Trait that the field types defined in …","","","","CCX_OTYPE_UNSEALED equivalent","ccx_offset_t Rust-land equivalent - should be a superset …","","","","CCX_PERM_GLOBAL equivalent These are the same for 64 and …","","","","","","","","","The bottom half of the capability as stored in memory.","The top of this capability’s valid address range. …","","","","","","","","","Import C functions for CC64,128.","Implements [CompressedCapability] for the CC128 …","Implements [CompressedCapability] for the CC64 capability …","","","Generate the <code>pesbt</code> bits for a capability (the top bits, …","Generate the <code>pesbt</code> bits for a capability (the top bits, …","The base of this capability’s valid address range. …","0 (false) if the bounds decode step was given an invalid …","The exponent used for storing the bounds. Stored from …","“Additional data stored by the caller.” Seemingly …","The top half of the capability as stored in memory.","Tag - if 1, this is a valid capability, 0 it’s just …","Decompress a (pesbt, cursor) pair into a capability. This …","Decompress a (pesbt, cursor) pair into a capability. This …","","","","Extracts the floating-point encoded bounds from […","","","","","Get a mask which aligns a bounds of some <code>length</code> to be …","Gets the flags from the [CcxCap::cr_pesbt] field","Gets the object type from the [CcxCap::cr_pesbt] field","Gets the hardware-defined permissions from the […","Get the minimum representable length greater than or …","Get the alignment required for bounds of some <code>length</code> to …","Gets the reserved bits from the [CcxCap::cr_pesbt] field","Gets the user/software-defined permissions from the […","","","","Helper function for easily calling FFI function […","Check if the range ([CcxCap::cr_base], [CcxCap::_cr_top]) …","Check if a capability with the parameters …","Helper function for easily calling FFI function […","","","Generate a capability for <code>base, top, cursor</code> with the …","Returns a <code>(tag, [cursor, pesbt])</code> tuple that represents …","","","","Returns a <code>(tag, [cursor, pesbt])</code> tuple that represents …","","","Sets the capability bounds to bounds that encompass …","Sets the base and top of this capability using C FFI …","","","","","","","","","","","","","","","","","","Updates the flags field in [CcxCap::cr_pesbt]","Updates the object type field in [CcxCap::cr_pesbt]","Updates the hardware-defined permissions field in […","Updates the reserved field in [CcxCap::cr_pesbt]","Updates the user/software-defined permissions field in […","Defines easy-to-use wrapper traits for […","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Defines the CC128 capability profile as an implementation …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Defines the CC64 capability profile as an implementation …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Trait exposing the utility functions used to specify …","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[1,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3,2,3,2,3,2,2,0,0,0,2,2,1,1,2,2,2,2,2,2,1,1,2,3,2,1,2,2,3,2,1,1,1,1,1,1,1,1,3,3,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,3,2,2,2,3,2,3,2,3,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],null,[[]],[[]],[[]],[[]],[[]],[[]],null,null,null,[[],["ccxcap",3]],[[]],[[["ccxcap",3]]],[[["ccxcap",3]]],null,null,null,null,null,null,[[["bool",15]],["ccxcap",3]],[[["bool",15]],["ccxcap",3]],[[]],null,[[],["bool",15]],[[],["ccxboundsbits",3]],[[],["u8",15]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],null,[[]],[[]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[],["ccxcap",3]],[[]],[[]],[[],["u32",15]],[[],["u32",15]],[[]],[[],["u8",15]],[[]],[[["ccxcap",3]],["bool",15]],[[],["bool",15]],[[["u8",15]]],[[["u32",15]]],[[["u32",15]]],[[["u8",15]]],[[["u32",15]]],[[["bool",15]]],[[],["u32",15]],null,[[],["bool",15]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["cc128",4]],[[]],[[["ccxcap",3]],["u64",15]],[[["ccxcap",3]],["u64",15]],[[["bool",15],["u64",15]],[["cc128",4],["ccxcap",3]]],[[["bool",15],["u64",15]],[["cc128",4],["ccxcap",3]]],[[],["ccxboundsbits",3]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[],[["cc128",4],["ccxcap",3]]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["bool",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],null,null,null,null,null,null,null,null,[[]],[[]],[[],["cc64",4]],[[]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[["u32",15],["bool",15]],[["cc64",4],["ccxcap",3]]],[[["u32",15],["bool",15]],[["cc64",4],["ccxcap",3]]],[[],["ccxboundsbits",3]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[["ccxcap",3]],["u32",15]],[[]],[[]],[[["ccxcap",3]],["u8",15]],[[["ccxcap",3]],["u32",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[]],[[],["bool",15]],[[["ccxcap",3]],["bool",15]],[[["bool",15]],["bool",15]],[[],[["cc64",4],["ccxcap",3]]],[[]],[[]],[[]],[[]],[[]],[[]],[[["ccxcap",3]],["bool",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u32",15]]],[[["ccxcap",3],["u8",15]]],[[["ccxcap",3],["u32",15]]],null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[],["bool",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[]]],"p":[[8,"CompressedCapability"],[3,"CcxCap"],[3,"CcxBoundsBits"],[4,"Cc128"],[4,"Cc64"],[8,"CheriRVFuncs"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};